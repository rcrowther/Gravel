python3

== Tokens
from Tokens import *
tokenToString
punctuationCodepoints

for k, v in punctuationCodepointToToken.items():
  print(k, tokenToString[v])

WHILE
INT_NUM

tokenToString[LSQUARE]


== Mark
from Mark import *
from Kinds  import *
globalPackage
gp = globalPackage
Mark('main', Any, gp)
canine = Mark('Canine', Any, gp)
Mark('Dogs', Any, canine)

== NameTable
from NameTable import *
t = ExpressionNameTable()
t.note('xbox', None)
# Note again
t.note('xbox', None)
# return the InfoNode. Should be isDefine = False, noteCount = 2
t('xbox')
# add a definition. Returns None
t.define('xbox', None)
# further attempts to add defintions should return the node
# isDefine = True, noteCount = 2
t.define('xbox', None)
# start with a definition
t.define('xbox1', None)
# note another instance
t.note('xbox1', None)
# isDefine = True, NoteCount = 1
t('xbox1')
# print
t

== KindNameTable
from NameTable import *
t = KindNameTable()
t

== Kinds
from Kinds import *
Any
AnyVal
AnyRef
Integer
Float
String
List(Integer)
Seq(Float) 
Iterable(AnyVal)

t = Integer
t.narrow(AnyVal)

l = List(Integer)
l.narrow(AnyVal)

=== MPTT
from KindTrees import MPTT, Node
t1 = Node()
t = MPTT(t1)
t2 = t.insert(t1, Node())
t3 = t.insert(t1, Node())
t4 = t.insert(t2, Node())
t5 = t.insert(t2, Node())
t
# = 1,2,4
t.parents(t4)
# 4,5
t.children(t2)
# True
t.isChild(t1, t5)
t.isParent(t4, t2)
# False
t.isChild(t2, t3)
t.isParent(t4, t3)

== KindNameTree
from KindTrees import KindNameTree
t = KindNameTree()
t
# 'AnyRef'
t.narrow('Seq', 'AnyRef')
t.narrow('AnyRef', 'Seq')
# 'Seq'
t.widen('Seq', 'AnyRef')
# None
t.widen('Map', 'String')

== Trees
from trees.Trees import *
from Position import NoPosition
mkSingleLineComment(NoPosition, 'No comment on single line comments')
mkMultiLineComment(NoPosition, 'Multiline comments?\nEasy')
mkParameterDefinition(NoPosition, 'xbox')
mkIntegerNamelessData(NoPosition, 44)
mkFloatNamelessData(NoPosition, 78.6)
mkStringNamelessData(NoPosition, 'doopy')
mkContextDefine(NoPosition, 'doopy')
mkContextCall(NoPosition, 'dpong')
mkMonoOpExpressionCall(NoPosition, 'dponth')
mkNamelessFunc(NoPosition)

== ScopeEntry
from Scope import *
from Marks import testMark, Mark
globalScope
ScopeEntry(testMark, globalScope)

== Scopes
from Scope import *
from Marks import testMark, testMark2, Mark
s = Scope()
s.isEmpty()
s.size()
s.addMark(testMark)
s.size()
s.addMark(testMark)
s.size()
s.addMark(testMark)
# is 3
s.size()
s.toList()
s
e = s.findEntry('TestMark')
s.findNextEntry(e)
# == False
s.containsName('testMark')
# == True
s.containsName('TestMark')
# == TestMark
s.findMark('TestMark')
sc = s.newChildScope()
sc
# == 1
sc.depth
# == 4
sc.size()
s.addUniqueMark(testMark)
s.addUniqueMark(testMark2)
