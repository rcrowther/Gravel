Most books available are bullshjt. Insiting on hauling undergraduates through lexing,
nothing on typing, nothing on JIT/assemblers/compilers, insisting on 
intermediate languages, etc. 

https://en.wikipedia.org/wiki/Category:Compiler_construction
--
val mit: int8
val mig: int16
val mut: int32
val mag: int64
val meg: int128

# (keyword params description body)(
     (lambda (x)
       "Return the hyperbolic cosine of X."
       (* 0.5 (+ (exp x) (exp (- x)))))

# (keyword name params description body)
      (defun capitalize-backwards ()
            "Upcase the last letter of the word at point."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))

# invoke
  (concat "a" "b")
  
# assign
   (let ((x 1)
                (x 2)) ... )


# This is interesting though, using curry type notation
# LISPy
+(5, \(4, 3))
# curry notate
5.+(4)./(3)
# drop points
5 +(4) /(3)
# assume brackets
5 + 4 / 3

== Issue

could have non-prefixed operattors?

++(2)
++ 2


big issue

4 + -34

operaters need brackets allowing

6 + (10/12)
! isn't this a nameless func, so more like 6 + {10/12}?
! ie: +(6, {/(10/12)})
! prefix/no prefix position ok. Postfix not ok, parameter ambiguous.

The problem is how to parse and tree-store this.
mono calls are dealt with (but need accounting for).

=== Syntax
Since we now have a token, monoOpCalls can now go any place an expression, optionally
        MonoOperaterIdentifier ~ MonoOpCallParameter ~ Option(Kind)
        MonoOpCallParameter = Option('(') ~ ExpressionSeq ~ Option(')')

==== Ops
Other ops continue to be a problem?

Must do,
If chained no brackets assume binop?
        OperaterIdentifier ~ OpCallParameters ~ Option(Kind)

        (OpCallParameters =  '(' ~ ExpressionSeq ~ ')' |
        Expression)
         ~ Option(Kind)

But won't work for chaining. could have seperate rules for chaining?

        OpChainCallParameter =  '(' ~ Expression ~ ')' 

So can do (with ops)
1 + 2 === 1.+(2)

With names
x + y === x.+(y)

But how does this stop?

The issue would seem to be this. Any operator could chain-binop to what
came before. That is what we are after, of course. But includes items
which are not 'operators' at all,

???

Other problems: assignment becomes a chained operator,

a = 1 + 2

Actually, that works. But anyway.

Kind might be taken as an operator?

gosh : Operator

No, colons are punctuation.

Unrelated operation may chain together,

res = magic >> 2
flip + dice

No intermediate operator, so should 
work. But if we allow standalone operater functions,

res = magic >> 2
**flip + dice

That will chain. That is bad. 

So our biuggest problems is accidental chaining. And ??? standalone marks. ?

infix anything ending in '='.

'|'
'||'
'^'
'&'
'&&'
'<'
'<<'
 '>'
'>>'
'=' '!'
??? ':'
'+' 
'++'
'-'
'--'
'*'
'/' 
'%'


== funcs vs. attributes (classic/Liskov)
ambiguous

functionCall
name()

symbolCall
name

Does it matter? They both return....



== returns
If .. return
NamelessData: data to label
Seq: last, and anyting labeled ''return', to label
ParamDefine : Nothing, it's a label
ContextDefine : the function to label
ContextCall : last of body seq
ConditionalCall : the last of body seq (if passes)
ConditionalContextCall: the last of body seq (if passes)
NamelessFunc: last of body seq
Assign:  last of body seq to label

... and
chainItem: to next
chainLast: to label

=== Return poitioning
After param calcs
if ... some loops


== Thoughts
There a connection between a partially applied function, and a data structure being partially filled. Explore...

Imports: Probaly more useful is where the file is used, not what is used there.
