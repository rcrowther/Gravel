Most books available are bullshjt. Insiting on hauling undergraduates through lexing,
nothing on typing, nothing on JIT/assemblers/compilers, insisting on 
intermediate languages, etc. 

https://en.wikipedia.org/wiki/Category:Compiler_construction
--
val mit: int8
val mig: int16
val mut: int32
val mag: int64
val meg: int128

# (keyword params description body)(
     (lambda (x)
       "Return the hyperbolic cosine of X."
       (* 0.5 (+ (exp x) (exp (- x)))))

# (keyword name params description body)
      (defun capitalize-backwards ()
            "Upcase the last letter of the word at point."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))

# invoke
  (concat "a" "b")
  
# assign
   (let ((x 1)
                (x 2)) ... )


# This is interesting though, using curry type notation
# LISPy
+(5, \(4, 3))
# curry notate
5.+(4)./(3)
# drop points
5 +(4) /(3)
# assume brackets
5 + 4 / 3

== Issue

could have non-prefixed operattors?

++(2)
++ 2


big issue

4 + -34

operaters need brackets allowing

6 + (10/12)
! isn't this a nameless func, so more like 6 + {10/12}?
! ie: +(6, {/(10/12)})
! prefix/no prefix position ok. Postfix not ok, parameter ambiguous.

ambiguous

functionCall
name()

symbolCall
name

Does it matter? They both return....

== returns
If .. return
NamelessData: data to label
Seq: last, and anyting labeled ''return', to label
ParamDefine : Nothing, it's a label
ContextDefine : the function to label
ContextCall : last of body seq
ConditionalCall : the last of body seq (if passes)
ConditionalContextCall: the last of body seq (if passes)
NamelessFunc: last of body seq
Assign:  last of body seq

... and
chainItem: to next
chainLast: to label

== Thoughts
There a connection between a partially applied function, and a data structure being partially filled. Explore...

Imports: Probaly more useful is where the file is used, not what is used there.
