= Usage

== Dealbreakers
All languagues have their oddities. Rubble less than many, I like to think, but it has them. And they are big. Here are the two biggest,
++
~ Functions only take one argument
: ...and one return. The builtin function handles one argument only. If you wish or need more, set them yourself
~ There is no if..else
: Again, you can fiddle with Rubble to provide an if..else, but there is no builtin function
+

There's more. which will be explained in greater detail somewhere or other but, quickly,
++
~ Functions take a fixed number of parameters
: There are no vargs. Though there is an ability to pass in arrays
~ 
:
+ 

Worth knowing is that there's a general policy, ''Rubble never stops you writing bad, if it can do good'. There is plenty of protection, warnings, and aftmeasure, but Rubble will not stop you outright.


== Base Syntax
All instructions in Rubble is are functions (not a ''lambda' or ''proc'). All functions have brackets. In the current compiler, functions are one per line,

?rubble
# function name ~ '(' ~ arguments ~')'
dec()
?

All functions take a fixed number of arguments.


=== How Rubble handles blocks in code sequences
There are no brackets for structuring function sequences. Blocking in code is stated explicitly, 
?rubble
frame()
    ...
frameEnd()
?


=== Whitespace and layout
In the current compiler, Rubble functions must be one per line. Other whitespace is irrelevant, so code can be spaced how you wish. I lean towards Python-style indenting,
?rubble
func(name: type)
    ...
    endFunc()
? 
but whitespace sizing is irrelevant.


=== Arguments
Every function can have arguments. These are bone-simple. 
+
134 = number
5.4 = float (because there's a period. Also 2.0)
""goof" = a string. note the double opening quotes
'doof' = also a string
+
Types default to the machine base. See later.

There is one twist. You can give some functions an argument list. An argument that is a list is formed with ''(' and '')',
?rbl
registersProtect(('rax', 'rbx'))
?



=== An arg can not be another function
Rubble is not a LISP. This will give an error,
?rbl
whileStart(dec(reg1))
?

There are two exceptions (eccept they are specific kinds). Declarations of data types, and of Boolean logic. See the relevant sections.


=== Commas
Rubble ignores commas. In the current compiler, commas are allowed between arguments,
??
sub(reg1, 30)
?
But nowhere else.



=== Comments
To put single-line comments into the code, use ''#',
?rbl
# I wanted to say...
?

Start multi-line comments with ''##', end with ''#',
?rbl
## This can start here...
and go on...
and on...
and on...
and on.
#
?

To put a comment into generated code,
?rbl
comment('See? I said it!')
?

== Printing


???Move down
== The two exceptions, functions in functions
We cover these in more depth when they are used,

=== Boolean Logic
Some functions accept Boolean logic, and this can be nested,
?rbl
ifStart( and(lt(3 reg1) lt(4 5)) )
?

== Typing
Many functions accept a type as an argument.

=== Rubbles types
The types are a small fixed set. They can be embedded. They look like this,
??
Bit8

ASCIIString

Array(Bit8, 4)
?


=== Type in Rubble is not for type-checking
You need to get past this. Rubble has types to reduce the syntax to a minimum. We can cover a lot of instructions by saying, ""This is an ''add' operation with type Bit64." Or Bit32, whatever.

In the high-level sense, the current compile does not check types at all. Even if a compiler or linter is produced that checks types, it will never stop you from casting them.


=== There is no way to add to the collection of types
In other languages, a ''class' definition will become a type. Rubble has no such notions.



== Vsriables
Rubble has some notion of ''variables'. The idea of variables is not a full abstraction. What happens is that you declare a variable, and the anme is attached to some kind of storage. Sometimes a Rubble variable can loose track of the storage, and sometimes storage can be used without a variable. That's why Rubble's variables are not a full mathematic representation. But the idea works a lot of the time.

=== Allocation
Sometimes you make a variable. What really happenins is that data is returned from a function that will be stored for later use. This data is associated with a label for later use. 
??
stringRODefine(@ro1 ""In a Silent Way")
?
Note the ''@' symbol. It says, ""Here is some text that will be used as a label for the data next time I use it". like this, 
??
stringRODefine(@ro1 ""In a Silent Way")
println(StrASCII ro1)
?


=== Allocation and definition are seperate
In Rubble, allocation is often separated from definition,
?rubble
stackAlloc(@str1 ASCII 15)
set(str1 "In a Silent Way")
?

=== Definition
Definition is fairly simple, if a bit crude at times. Put ''777' in index ''3' of an array,
?rbl
define(@array1 3 777)
?

=== Retrieval


== Functions by group
General info on different groups of functions.

Rubble may not be a clever thing, but it has weird moments. Even if you are an expert, please glance over this. Other people will be fine.


=== Arithmetic

=== Boolean and switches

==== cmp
Put a boolean into a variable,
?rl
cmp(reg1, booleanCondition)
?
In Assembly, thats a painful job. In Rubble, it's bad Assembly.


==== If
?rl
ifStart (booleanCondition)
ifEnd()
?

===== Rubble has no ''if..else' statement
Nope. No ''else'. Use two ifs in a row. Or get clever.
 


==== Switch
?rl
switchStart(varInt)
whenStart(valInt)
whenEnd()
whenStart(default)
whenEnd()

switchEnd()
?

e.g.

?rl
switchStart(varInt)
    whenStart(3)
        println('Free!')
        whenEnd()

    whenStart(4)
        println('Fore!')
        whenEnd()
switchEnd()
?

Rubble's switch is weird. First, Pascal-like, it has no fallthrough. Second, if nothing matches, it does nothing. That's it, nothing. Like an if().


== Loops
=== forRange
It's a from..until. Like this,
?rl
forRangeStart(protosymbol, reg, varOrInt)
forRangeEnd()
?

It makes a variable then runs through the numbers. 
?rl
forRangeStart(@loop, 'rbx', 10, -3)
    println(loop)
    forRangeEnd()
?
Prints the numbers from 10 to -2.

It's not a real range. Rannge doesn't exist as an object.

===
